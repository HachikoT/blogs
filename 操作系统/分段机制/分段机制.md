- [实模式下的分段机制](#实模式下的分段机制)
- [保护模式下的分段机制](#保护模式下的分段机制)
- [参考资料](#参考资料)

# 实模式下的分段机制

也就是8086的16位模式，16位的段寄存器左移4位（变为20位大小）作为段基址，再加上相应的段偏移值就得到了最终的地址。

比如对于代码段（code segment），计算`%CS<<4+%EIP`就是当前实际要寻址的代码地址。

# 保护模式下的分段机制

这时，段寄存器的值并不是直接作为段偏移，而是分为了三部分：

![selector](selector.png)

- 索引（INDEX）：在描述符表中的下标值，最多$2^{13}=8192$个描述符。
- 表指示位（Table Indicator）：表示该访问哪一个描述符表，0表示全局描述符表（GDT），1表示局部描述符表（LDT）。
- 需要的特权级（Requested Previlege Level）：0表示内核态，3表示用户态。

段描述符一共64bit，其中包括32位的基地址，20位的段大小，段的类型等。

![seg-descriptor](seg-descriptor.png)

- 颗粒度（G granularity）：段的大小单位，0表示单位为1Byte，那么段最大为1MB，1表示单位为4KB，那么段最大为4GB。
- 段的类型（S+Type）：S和Type两个字段决定了描述符的类型，当S为0时，则表示是系统描述符，比如LDT的段描述符，任务状态描述符，中断门描述符等，Type就是用来表示具体是哪一种。当S为1时，表示是代码或者数据段，Type就用来决定读/写/执行，段的扩展方向等属性。
- 描述符特权级（DPL Descriptor previlege level）：用来实现特权级。
- 段存在位（P segment present）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。

# 参考资料

- [IA-32保护模式下的内存管理-分段](https://zhuanlan.zhihu.com/p/57143407)
