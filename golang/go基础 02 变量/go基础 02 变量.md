- [变量声明](#变量声明)
	- [指明变量类型](#指明变量类型)
	- [类型自动推导](#类型自动推导)
	- [简短类型声明](#简短类型声明)
- [变量作用域](#变量作用域)
- [参考资料](#参考资料)

# 变量声明

## 指明变量类型

可以一次声明多个同类型变量。如果不赋值那么就为默认初始值。

```go
var i int           // 默认初始值
var i, j int        // 一次声明多个同类型变量
var i, j int = 1, 2 // 给变量赋上初始值
```

## 类型自动推导

类型自动推导，可以一次声明多个不同类型的变量。

```go
var i = 1             // 类型自动推导
var i, s = 1, "hello" // 一次声明多个不同类型变量

// 更好看的形式，多行声明，可用于声明全局变量
var (
	i = 1
	s = "hello"
)
```

## 简短类型声明

通过`:=`操作符，将变量声明和赋值合二为一。

```go
i := 1             // 简短类型声明
i, s := 1, "hello" // 一次声明多个不同类型变量
```

简短声明不能用于全局变量。

```go
package main

import "fmt"

count = 10     // 编译报错 expected declaration, found count
var count = 10 // ok

func main() {
	fmt.Println(count)
}
```

等式左边必须至少包含一个全新的变量名，不然编译会报错。

```go
i, j := 10, 20
i, j := 30, 40  // 编译报错 no new variables on left side of :=
i, k := 30, 40  // ok k为新变量，i被重新赋值
```

# 变量作用域

当进入子作用域的时候，可以使用同名的变量，这时会起到覆盖的作用。

```go
func main() {
	n := 1
	{
		n := "hello"
		fmt.Println(n) // 输出 hello
	}
	fmt.Println(n) // 输出 1
}
```

这个规则遇到简短类型声明包含已有变量的时候也是成立的，子作用域中还是新的变量。

```go
func main() {
	n, m := 1, 2
	{
		n, k := 3, 4
		fmt.Println(n, k) // 输出 3, 4 这里n和k都是新变量
	}
	fmt.Println(n, m) // 输出 1, 2
}
```

# 参考资料

- [Go 语言变量](https://www.runoob.com/go/go-variables.html)
