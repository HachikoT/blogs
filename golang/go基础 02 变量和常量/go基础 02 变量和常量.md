- [变量](#变量)
  - [变量声明](#变量声明)
  - [变量作用域](#变量作用域)
  - [变量生命周期](#变量生命周期)
- [常量](#常量)
  - [常量iota](#常量iota)
- [参考资料](#参考资料)

# 变量

## 变量声明

1. **指明变量类型**

可以一次声明多个同类型变量，如果不赋值则为默认初始值，支持多行声明。

```go
var i int
var i, j int = 1, 2
var (
	i int
	j int = 2
)
```

2. **类型自动推导**

可以一次声明多个不同类型变量并赋初值，支持多行声明。

```go
var i = 1
var i, s = 1, "hello"
var (
	i = 1
	s = "hello"
)
```

3. **简短变量声明**

可以一次声明多个不同类型变量并赋初值，简短声明不支持多行声明，不支持全局变量。

同一作用域，等式左边必须至少包含一个全新的变量名，不然编译会报错。

```go
i := 1
i, s := 1, "hello"
{
	i, s := 1, "hello"
	i, s := 2, "world"  // 编译报错 no new variables on left side of :=
}
```

## 变量作用域

1. **导出全局变量**

函数外定义的变量就是全局变量，但是默认全局变量只能在包内可见，要包外也可见，变量名就必须以大写字母开头。

```go
func main() {
	// Args就是os包中定义的全局变量
	// var Args []string
	fmt.Println(os.Args)
}

```

2. **作用域覆盖**

当进入子作用域的时候，如果出现同名的变量，则会起到覆盖的作用（就近原则）。

这个规则遇到简短变量声明也是成立的，子作用域中都是新的变量。

```go
func main() {
	n, m := 1, 2
	{
		n, k := 3, 4
		fmt.Println(n, k) // 输出 3, 4 这里n和k都是新变量
	}
	fmt.Println(n, m) // 输出 1, 2
}
```

## 变量生命周期

go语言是支持gc的，堆和栈上申请的对象都不用手动去释放内存，所以不用特别去关注变量的生命周期，只要你能拿到变量，它就是存在的。

这里有一点比较有趣，局部变量不一定是在栈上分配的，而`new`出来的对象也不一定是在堆上分配的，编译器会根据实际的情况去优化。

```go
var global *int

func f() {
	// x 在堆上分配
	var x int
	x = 1
	global = &x
}

func g() {
	// y 在栈上分配
	y := new(int)
	*y = 1
}
```

# 常量

常量和变量是一样的，只是前面的`var`换成了`const`，并且常量必须在声明的时候就赋值。

并且常量的数据类型只能是基本类型（布尔型、数值型、字符串）。

## 常量iota

在常量的多行声明中，可以不指定右侧的表达式，但第一个常量必须指定，忽略右侧表达式的常量相当于重写了一遍上一个常量右侧的表达式。

`iota`在go中是特殊的关键字，表示常数生成器，其值为当前所在行数（从0开始计数）。

```go
const (
    thumb = 100
    index
    middle = iota
    ring
    pinky
)

fmt.Println(thumb, index, middle, ring, pinky) // 输出100 100 2 3 4
```

# 参考资料

- [Go 语言变量](https://www.runoob.com/go/go-variables.html)
- [golang 使用 iota ](https://studygolang.com/articles/2192)
