- [if](#if)
- [switch](#switch)
- [for](#for)

# if

```go
// 基本用法
if condition {
	// 代码
}

// 带初始化语句
if x := 10; x > 5 {
	// 代码
}

// if-else
if condition {
	// 代码
} else {
	// 代码
}

// if-else if-else
if condition1 {
	// 代码
} else if condition2 {
	// 代码
} else {
	// 代码
}
```

# switch

```go
// 支持传入各种类型进行选择，必须要显式写明fallthrough语句才会接着执行下一个case
func main() {
	var weakDay string
	fmt.Scan(&weakDay)
	switch weakDay {
	case "Mon.":
		fmt.Println(1)
	case "Tues.":
		fmt.Println(2)
	case "Wed.":
		fmt.Println(3)
	case "Thurs.":
		fmt.Println(4)
	case "Fri.":
		fmt.Println(5)
	case "Sat.":
		fmt.Println(6)
	case "Sun.":
		fmt.Println(7)
	default:
		panic("wrong day")
	}
}

// 支持单个case包含多个条件
func main() {
	var weakDay string
	fmt.Scan(&weakDay)
	switch weakDay {
	case "Mon.", "Tues.", "Wed.", "Thurs.", "Fri.":
		fmt.Println("work day")
	case "Sat.", "Sun.":
		fmt.Println("weakend")
	default:
		panic("wrong day")
	}
}

// 可以不传入参数，替代if else写法。这里每个case挨个判断，进入最先满足条件的case执行
func main() {
	var score int
	fmt.Scan(&score)
	switch {
	case score < 60:
		fmt.Println("不及格")
	case score >= 60 && score < 80:
		fmt.Println("不错")
	case score >= 80:
		fmt.Println("优秀")
	default:
		panic("wrong number")
	}
}

// type switch要求进行断言的变量必须是接口类型。并且在不允许使用fallthrough语句
type person struct {
	age  int
	name string
}

func guessType(x interface{}) {
	switch value := x.(type) {
	case int:
		fmt.Println("int ", value)
	case string:
		fmt.Println("string ", value)
	case person:
		fmt.Println("person ", value)
	default:
		fmt.Println("unknown ", value)
	}
}

func main() {
	var n int
	var str string = "hello"
	var p person
	guessType(n)   // int 0
	guessType(str) // string hello
	guessType(p)   // person {0 }
	guessType(nil) // unknown <nil>
}
```

# for

```go
// 无限循环
for {
	// 代码
}

// 基本for循环
for i := 0; i < 10; i++ {
	// 代码
}

// 遍历字符串
str := "hello world"
for idx, ch := range str {
	// 代码，这里ch是rune类型
}

// 遍历数组/切片
numbers := []int{1, 2, 3}
for idx, value := range numbers {
	// 代码，切片为nil也可以正常遍历
}

// 遍历map
m := map[string]int{"a": 1, "b": 2}
for key, value := range m {
	// 代码，map为nil也可以正常遍历
}

// 遍历通道
ch := make(chan int)
for value := range ch {
	// 代码，当通道被关闭时结束遍历
}
```
