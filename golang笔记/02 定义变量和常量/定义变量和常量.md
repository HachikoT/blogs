- [定义变量](#定义变量)
  - [导出全局变量](#导出全局变量)
  - [作用域覆盖](#作用域覆盖)
  - [变量是分配在栈上还是堆上](#变量是分配在栈上还是堆上)
- [定义常量](#定义常量)
  - [常量iota](#常量iota)
- [参考资料](#参考资料)

# 定义变量

- **显示类型声明**

```go
// 可以一次声明多个同类型变量，如果不赋值则为默认初始值，支持多行声明
var i int
var i, j int = 1, 2
var (
	i int
	j int = 2
)
```

- **类型推断声明**

```go
// 可以一次声明多个不同类型变量并赋初值，支持多行声明
var i = 1
var i, s = 1, "hello"
var (
	i = 1
	s = "hello"
)
```

- **短变量声明（仅在函数内部使用）**

```go
// 可以一次声明多个不同类型变量并赋初值，短变量声明不支持多行声明，不支持全局变量声明
// 同一作用域，等式左边必须至少包含一个全新的变量名，不然编译会报错
i := 1
i, s := 1, "hello"
{
	i, s := 1, "hello"
	i, s := 2, "world"  // 编译报错 no new variables on left side of :=
}
```

## 导出全局变量

函数外定义的变量就是全局变量，但是默认全局变量只在包内可见，要包外也可见，变量名就必须以大写字母开头。

```go
func main() {
	// Args就是os包导出的全局变量（var Args []string）
	fmt.Println(os.Args)
}
```

## 作用域覆盖

当进入子作用域的时候，如果出现同名的变量，则会起到覆盖的作用（就近原则）。

这个规则遇到简短变量声明也是成立的，子作用域中都是新的变量。

```go
func main() {
	n, m := 1, 2
	{
		n, k := 3, 4
		fmt.Println(n, k) // 输出 3, 4 这里n和k都是新变量
	}
	fmt.Println(n, m) // 输出 1, 2
}
```

## 变量是分配在栈上还是堆上

局部变量不一定是在栈上分配的，而`new`出来的对象也不一定是在堆上分配的，编译器会根据实际的情况去优化。

```go
var global *int

func f() {
	// x 在堆上分配
	var x int
	x = 1
	global = &x
}

func g() {
	// y 在栈上分配
	y := new(int)
	*y = 1
}
```

# 定义常量

常量和变量是一样的，只是前面的`var`换成了`const`：

- **常量必须在声明的时候就赋值，并且不能被重新赋值**
- **常量的数据类型只能是基本类型（布尔型、数值型、字符串）**

## 常量iota

在常量的多行声明中，可以不指定右侧的表达式，但第一个常量必须指定，忽略右侧表达式的常量相当于重写了一遍上一个常量右侧的表达式。

`iota`在go中是特殊的关键字，表示常数生成器，其值为当前所在行数（从0开始计数）。

```go
const (
    thumb = 100
    index
    middle = iota
    ring
    pinky
)

fmt.Println(thumb, index, middle, ring, pinky) // 输出100 100 2 3 4
```

# 参考资料

- [Go 语言变量](https://www.runoob.com/go/go-variables.html)
- [golang 使用 iota ](https://studygolang.com/articles/2192)
